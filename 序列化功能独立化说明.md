# 序列化功能独立化说明

## 概述

按照您的要求，我已经成功将 `envConfigs.js` 中的序列化和反序列化功能独立出来，创建了一个专门的 `serialization.js` 模块。这样做的好处是：

1. **其他模式可以直接引用**: 其他模式现在可以直接导入 `serialization.js` 来使用序列化/反序列化功能
2. **主模式保持原有调用方式**: `envConfigs.js` 继续引用并重新导出这些功能，主模式的代码无需修改
3. **代码复用**: 避免了重复实现相同的序列化逻辑
4. **更清晰的职责分离**: 序列化功能现在有了专门的模块

## 文件结构

### 新创建的文件

1. **`src/components/Data/store-parts/serialization.js`** - 独立的序列化/反序列化模块
2. **`src/components/Othermodes/exampleUsage.js`** - 其他模式使用示例

### 修改的文件

1. **`src/components/Data/store-parts/envConfigs.js`** - 现在作为接口层，引用序列化模块

## 核心功能

### serialization.js 提供的功能

#### 序列化工具函数
- `stableStringify(obj)` - 稳定化 JSON 序列化
- `hashString(str)` - 字符串哈希计算

#### 数据规范化函数
- `normalizeCards(store, cards)` - 规范化卡片数据
- `normalizeOptions(store, options)` - 规范化选项数据
- `buildEnvironmentFromSession(store)` - 从会话数据构建环境配置
- `buildFullConfigs(env)` - 构建完整配置对象

#### 核心序列化/反序列化功能
- `loadEnvironmentConfigs(ctx)` - 加载环境配置（反序列化）
- `saveEnvironmentConfigs(ctx, configs)` - 保存环境配置（序列化）
- `saveEnvFullSnapshot(store, versionLabel)` - 保存全量环境快照
- `applyEnvFullSnapshot(store, versionLabel)` - 应用全量环境快照（反序列化并恢复）
- `listEnvFullSnapshots(store)` - 列出所有环境全量快照

#### 辅助工具函数
- `getAllOptionsByCardId(store, cardIdInput)` - 根据卡片ID获取所有选项

#### 聚合对象
```javascript
export const Serialization = Object.freeze({
  // 所有上述功能的聚合访问
  // 内部工具通过 Serialization._internal 访问
});
```

## 使用方法

### 主模式（无需修改）

主模式继续通过 `envConfigs.js` 使用所有功能：

```javascript
import { 
  loadEnvironmentConfigs, 
  saveEnvironmentConfigs,
  saveEnvFullSnapshot,
  applyEnvFullSnapshot 
} from '../store-parts/envConfigs.js';

// 使用方式完全不变
const config = await loadEnvironmentConfigs(store);
```

### 其他模式（新的使用方式）

#### 方式1：直接导入需要的功能

```javascript
import { 
  loadEnvironmentConfigs,
  saveEnvironmentConfigs,
  applyEnvFullSnapshot,
  listEnvFullSnapshots
} from '../Data/store-parts/serialization.js';

// 构造上下文
const ctx = {
  currentModeId: 'your_mode_id',
  currentVersion: 'V1.0',
  dataManager: {
    longTermStorage: localStorage
  }
};

// 直接使用
const config = await loadEnvironmentConfigs(ctx);
```

#### 方式2：使用聚合对象

```javascript
import { Serialization } from '../Data/store-parts/serialization.js';

// 使用聚合对象访问所有功能
const config = await Serialization.loadEnvironmentConfigs(ctx);
const hash = Serialization.hashString('some data');
```

#### 方式3：通过便利类（推荐）

```javascript
import { createSubModeHandler } from '../Othermodes/exampleUsage.js';

const handler = createSubModeHandler('your_mode_id');
const config = await handler.loadConfig();
const snapshots = await handler.listSnapshots();
```

## 上下文参数说明

序列化功能需要一个上下文对象，包含以下字段：

```javascript
const ctx = {
  // 必需字段
  currentModeId: 'string',      // 模式ID，如 'root_admin', 'zhang_san' 等
  currentVersion: 'string',     // 当前版本号，如 'V1.0', 'V2.0' 等
  
  // 存储相关
  dataManager: {
    longTermStorage: Storage    // 存储实现，通常是 localStorage
  },
  
  // 可选字段（用于快照功能）
  sessionCards: Array,          // 当前会话卡片数据
  error: string|null,          // 错误状态
  
  // 兼容字段
  version: 'string',           // 版本号的别名
  versionLabel: 'string'       // 版本标签的别名
};
```

## 关键特性

### 1. 五段Key系统支持
所有序列化功能都支持五段Key系统：
- `prefix:modeId:version:type:excelId`
- 自动处理不同模式的数据隔离

### 2. 版本化数据管理
- 支持多版本数据存储和管理
- 版本间数据独立，互不干扰

### 3. 兼容性保障
- 主模式的所有现有代码无需修改
- 向后兼容旧的数据格式
- 自动迁移旧版数据格式

### 4. 错误处理
- 完整的错误处理机制
- 详细的调试日志
- 数据校验和结构检查

## 注意事项

1. **模式ID**: 其他模式使用时必须提供正确的 `currentModeId`
2. **版本号**: 建议使用有意义的版本号，如 'V1.0', 'V2.0' 等
3. **存储**: 确保提供有效的存储实现（通常是 `localStorage`）
4. **数据结构**: 序列化的数据必须符合预定义的结构要求

## 测试建议

建议测试以下场景：
1. 主模式的现有功能是否正常工作
2. 其他模式能否正确导入和使用序列化功能
3. 不同模式的数据是否正确隔离
4. 版本化数据管理是否正常工作

## 总结

这次重构成功实现了您的需求：
- ✅ 序列化功能独立到 `serialization.js`
- ✅ 其他模式可直接引用序列化模块
- ✅ 主模式继续通过 `envConfigs.js` 使用，无需修改现有代码
- ✅ 保持了完整的功能兼容性
- ✅ 提供了清晰的使用示例和文档